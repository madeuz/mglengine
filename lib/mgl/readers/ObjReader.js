/* *  MglEngine - WebGL engine programming library *  Copyright (C) 2011  Mateusz Szczygielski * * This software is provided 'as-is', without any express or implied * warranty. In no event will the authors be held liable for any damages * arising from the use of this software. * * Permission is granted to anyone to use this software for any purpose, * including commercial applications, and to alter it and redistribute it * freely, subject to the following restrictions: * *    1. The origin of this software must not be misrepresented; you must not *    claim that you wrote the original software. If you use this software *    in a product, an acknowledgment in the product documentation would be *    appreciated but is not required. * *    2. Altered source versions must be plainly marked as such, and must not *    be misrepresented as being the original software. * *    3. This notice may not be removed or altered from any source *    distribution. *//** * @class mgl.ObjReader * Wavefront OBJ reader class * @constructor * @param {String} data OBJ file data */mgl.ObjReader = function(data){	var lines = data.split('\n');		var vNum = 0, vnNum = 0, vtNum = 0, iNum = 0, type, tmp, j, 		rx = /[a-z_]+/, rs = /\s+/g;		for(var i = 0, length = lines.length; i < length; i++){		type = rx.exec(lines[i]);		if(type){			type = type[0];			if(type == 'v')				vNum++;			else if(type == 'vn')				vnNum++;			else if(type == 'vt')				vtNum++;			else if(type == 'f'){				iNum += 3;				tmp = lines[i].replace(rs, ' ').split(' ');				if(tmp.length > 4)					for(j = 4; j < tmp.length; j++)						if(tmp[j] != '')							iNum += 3;			}		}	}		var vTemp = new Float32Array(vNum*3);	var vnTemp = new Float32Array(vnNum*3);	var vtTemp = new Float32Array(vtNum*2);		vNum = 0; vnNum = 0; vtNum = 0;	for(var i = 0, length = lines.length; i < length; i++){		type = rx.exec(lines[i]);		if(type){			type = type[0];			if(type == 'v'){				tmp = lines[i].replace(rs, ' ').split(' ');				vTemp[vNum] = parseFloat(tmp[1]);				vTemp[vNum+1] = parseFloat(tmp[2]);				vTemp[vNum+2] = parseFloat(tmp[3]);				vNum+=3;			}			else if(type == 'vn'){				tmp = lines[i].replace(rs, ' ').split(' ');				vnTemp[vnNum] = parseFloat(tmp[1]);				vnTemp[vnNum+1] = parseFloat(tmp[2]);				vnTemp[vnNum+2] = parseFloat(tmp[3]);				vnNum+=3;			}			else if(type == 'vt'){				tmp = lines[i].replace(rs, ' ').split(' ');				vtTemp[vtNum] = parseFloat(tmp[1])/2;				vtTemp[vtNum+1] = parseFloat(tmp[2])/2;				vtNum+=2;			}		}	}		var vertices = new Float32Array(iNum*3);	var normals = new Float32Array(iNum*3);	var texCoords = new Float32Array(iNum*2);	var indices = new Uint16Array(iNum);		var vert, vertn, j, v, vt = 0, vn = 0, indexNum = 0, v3, vt3, vn3;	for(var i = 0, length = lines.length; i < length; i++){		type = rx.exec(lines[i]);		if(type){			type = type[0];			if(type == 'f'){								tmp = lines[i].replace(rs, ' ').split(' ');								for(j = 1; j < 4; j++){					vert = tmp[j].split('/');					if(vert.length == 1){						indices[indexNum] = indexNum;						v = parseInt(vert[0])-1;						v3 = v*3;						vertices.set(vTemp.subarray(v3, v3+3), indexNum*3);					}					else if(vert.length == 2){						v = parseInt(vert[0])-1;						vt = parseInt(vert[1])-1;												indices[indexNum] = indexNum;												v3 = v*3;						vertices.set(vTemp.subarray(v3, v3+3), indexNum*3);												vt2 = vt*2;						texCoords.set(vtTemp.subarray(vt2, vt2+2), indexNum*2);					}					else if(vert.length == 3){						v = parseInt(vert[0])-1;						vt = parseInt(vert[1])-1;						vn = parseInt(vert[2])-1;												indices[indexNum] = indexNum;												v3 = v*3;						vertices.set(vTemp.subarray(v3, v3+3), indexNum*3);												if(vt){							vt2 = vt*2;							texCoords.set(vtTemp.subarray(vt2, vt2+2), indexNum*2);						}												vn3 = vn*3;						normals.set(vnTemp.subarray(vn3, vn3+3), indexNum*3);					}					indexNum++;				}								if(tmp.length > 4){					for(j = 4; j < tmp.length && tmp[j] != ''; j++){						vert = tmp[j].split('/');						if(vert.length == 1){							indices[indexNum] = indexNum;							v = parseInt(tmp[1])-1;							v3 = v*3;							vertices.set(vTemp.subarray(v3, v3+3), indexNum*3);														indexNum++							indices[indexNum] = indexNum;							v = parseInt(tmp[j-1])-1;							v3 = v*3;							vertices.set(vTemp.subarray(v3, v3+3), indexNum*3);														indexNum++							indices[indexNum] = indexNum;							v = parseInt(vert[0])-1;							v3 = v*3;							vertices.set(vTemp.subarray(v3, v3+3), indexNum*3);						}						else if(vert.length == 2){							indices[indexNum] = indexNum;							vertn = tmp[1].split('/');							v = parseInt(vertn[0])-1;							vt = parseInt(vertn[1])-1;							v3 = v*3;							vertices.set(vTemp.subarray(v3, v3+3), indexNum*3);							vt2 = vt*2;							texCoords.set(vtTemp.subarray(vt2, vt2+2), indexNum*2);														indexNum++							indices[indexNum] = indexNum;							vertn = tmp[j-1].split('/');							v = parseInt(vertn[0])-1;							vt = parseInt(vertn[1])-1;							v3 = v*3;							vertices.set(vTemp.subarray(v3, v3+3), indexNum*3);							vt2 = vt*2;							texCoords.set(vtTemp.subarray(vt2, vt2+2), indexNum*2);														indexNum++							indices[indexNum] = indexNum;							v = parseInt(vert[0])-1;							vt = parseInt(vert[1])-1;							v3 = v*3;							vertices.set(vTemp.subarray(v3, v3+3), indexNum*3);							vt2 = vt*2;							texCoords.set(vtTemp.subarray(vt2, vt2+2), indexNum*2);						}						else if(vert.length == 3){							indices[indexNum] = indexNum;							vertn = tmp[1].split('/');							v = parseInt(vertn[0])-1;							vt = parseInt(vertn[1])-1;							vn = parseInt(vertn[2])-1;							v3 = v*3;							vertices.set(vTemp.subarray(v3, v3+3), indexNum*3);							if(vt){								vt2 = vt*2;								texCoords.set(vtTemp.subarray(vt2, vt2+2), indexNum*2);							}							vn3 = vn*3;							normals.set(vnTemp.subarray(vn3, vn3+3), indexNum*3);														indexNum++							indices[indexNum] = indexNum;							vertn = tmp[j-1].split('/');							v = parseInt(vertn[0])-1;							vt = parseInt(vertn[1])-1;							vn = parseInt(vertn[2])-1;							v3 = v*3;							vertices.set(vTemp.subarray(v3, v3+3), indexNum*3);							if(vt){								vt2 = vt*2;								texCoords.set(vtTemp.subarray(vt2, vt2+2), indexNum*2);							}							vn3 = vn*3;							normals.set(vnTemp.subarray(vn3, vn3+3), indexNum*3);														indexNum++							indices[indexNum] = indexNum;							v = parseInt(vert[0])-1;							vt = parseInt(vert[1])-1;							vn = parseInt(vert[2])-1;							v3 = v*3;							vertices.set(vTemp.subarray(v3, v3+3), indexNum*3);							if(vt){								vt2 = vt*2;								texCoords.set(vtTemp.subarray(vt2, vt2+2), indexNum*2);							}							vn3 = vn*3;							normals.set(vnTemp.subarray(vn3, vn3+3), indexNum*3);						}						indexNum++;					}				}			}		}	}		this.vertices = vertices;	this.normals = normals;	this.texCoords = texCoords;	this.indices = indices;}